<template>
  <div :class="wrapCls"
       ref="banner">
    <div :class="innerCls"
         ref="bannerInner"
         @touchstart="touchstartBannerInner"
         @touchmove.prevent="touchmoveInner"
         @touchend="touchendBannerInner">
      <div class="list"
           ref="list">
        <slot></slot>
      </div>
      <div class="list-copy">
        <slot></slot>
      </div>
    </div>
  </div>
</template>

<script>
import {oneOf} from '../../utils/assist.js'
const prefixCls = 'r--banner'

export default {
  name: 'Banner',
  provide () {
    return {
      banner: this
    }
  },
  props: {
    // 指针
    pointer: {
      type: Number,
      default: 0
    },
    // 运动方向
    direction: {
      type: String,
      validator (value) {
        return oneOf(value, ['scrollLeft', 'scrollTop'])
      },
      default: 'scrollLeft'
    },
    // 运动距离
    distance: Number,
    // 运动间隔时长
    gap: {
      type: Number,
      default: 2000
    }
  },
  data () {
    return {
      list: [],
      mark: this.pointer,
      maxScroll: 0, // 最大移动距离
      onceMoveDistance: 0, // 一次运动距离
      startCoor: 0, // 鼠标起始位置
      lastScroll: 0, // 上一次滚动位置
      bannerWidth: 0,
      bannerHeight: 0
    }
  },
  computed: {
    wrapCls () {
      return [
        prefixCls,
        `${prefixCls}-direction-${this.direction == 'scrollLeft' ? 'left' : 'top'}`
      ]
    },
    innerCls () {
      return `${prefixCls}-inner`
    },
    listCls () {
      return `${prefixCls}-list`
    }
  },
  mounted () {
    this.$nextTick(() => {
      this.maxScroll = this.direction == 'scrollLeft' ? this.$refs.list.offsetWidth : this.$refs.list.offsetHeight
      this.onceMoveDistance = this.distance || this.maxScroll * 2 / this.list.length || 0
      this.bannerWidth = this.$refs.banner.offsetWidth
      this.bannerHeight = this.$refs.banner.offsetHeight
      // 启动动画
      this.gapTimer = setTimeout(() => {
        this.plus()
      }, this.gap);
    })
  },
  methods: {
    touchstartBannerInner (e) {
      clearInterval(this.moveTimer)
      clearTimeout(this.gapTimer)
      this.lastScroll = this.$refs.banner[this.direction]
      this.startCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
    },
    touchmoveInner (e) {
      let currCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
      if (currCoor > this.startCoor && this.lastScroll == 0) {
        this.$refs.banner[this.direction] = this.lastScroll = this.maxScroll
        this.mark = this.list.length / 2
      }
      this.$refs.banner[this.direction] = this.lastScroll + this.startCoor - currCoor
    },
    touchendBannerInner (e) {
      let endCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
      let movePercent = Math.abs(this.startCoor - endCoor) / (this.direction == 'scrollLeft' ? this.bannerWidth : this.bannerHeight) * 100
      if (movePercent > 20) {
        if (endCoor > this.startCoor) {
          this.minus()
        } else {
          this.plus()
        }
      } else {
        if (endCoor > this.startCoor && this.lastScroll == this.maxScroll) {
          this.$refs.banner[this.direction] = this.lastScroll = 0
          this.mark = 0
        }
        this.$refs.banner[this.direction] = this.lastScroll
        // 启动动画
        this.gapTimer = setTimeout(() => {
          this.plus()
        }, this.gap);
      }
    },
    // +动画
    plus () {
      let self = this
      this.mark += 1
      move({
        obj: this,
        beginningValue: this.$refs.banner[this.direction],
        endValue: this.mark * self.onceMoveDistance,
        step (v) {
          self.$refs.banner[self.direction] = v
        },
        callback () {
          let d = self.$refs.banner[self.direction]
          if (d >= self.maxScroll) {
            self.$refs.banner[self.direction] = 0
            self.mark = 0
          }
          self.gapTimer = setTimeout(() => {
            self.plus()
          }, self.gap);
        }
      })
    },
    // -动画
    minus () {
      let self = this
      this.mark -= 1
      move({
        obj: this,
        beginningValue: this.$refs.banner[this.direction],
        endValue: this.mark * self.onceMoveDistance,
        step (v) {
          self.$refs.banner[self.direction] = v
        },
        callback () {
          self.gapTimer = setTimeout(() => {
            self.plus()
          }, self.gap);
        }
      })
    },
    beforeDestroy () {
      clearInterval(this.moveTimer)
      clearTimeout(this.gapTimer)
    }
  }
}
/*
 * Tween.js
 * t: current time（当前时间）；
 * b: beginning value（初始值）；
 * c: change in value（变化量）；
 * d: duration（持续时间）。
*/
var Tween = {
  linear: function (t, b, c, d) {  // 匀速
    return c * t / d + b;
  }
}

function move ({ obj, beginningValue, endValue, step, callback }) {
  if (!obj) return
  if (obj.isMoving) return
  obj.isMoving = true
  let b = beginningValue // 初始化值
  let c = endValue - beginningValue // 变化值
  let d = 300; // 持续时间
  let sTime = new Date().getTime();
  clearInterval(obj.moveTimer)
  obj.moveTimer = setInterval(function () {
    let eTime = new Date().getTime()
    let t = eTime - sTime;
    if (t >= d) t = d
    step && step(Tween.linear(t, b, c, d))
    if (t >= d) {
      clearInterval(obj.moveTimer)
      callback && callback()
      obj.isMoving = false
    }
  }, 10)
}
</script>

<style lang="less">
@bannerCls: r--banner;
.@{bannerCls} {
  position: relative;
  width: 100%;
  overflow: hidden;
  &-direction-left &-inner {
    width: 90000px;
  }
  &-direction-left .list,
  &-direction-left .list-copy {
    float: left;
  }
  &-direction-left &-item {
    float: left;
    width: 20rem;
  }
  &-direction-left &-inner::after {
    content: "";
    display: block;
    clear: both;
  }
  &-direction-top &-inner {
    height: 100px;
  }
}
</style>
