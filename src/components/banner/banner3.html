<template>
  <div :class="wrapCls"
       ref="banner"
       style="padding: 30px 0; background: red">
       {{mark+'dfsd'}}
    <div :class="innerCls"
         ref="bannerInner"
         @touchstart="touchstartBannerInner"
         @touchmove.prevent="touchmoveInner"
         @touchend="touchendBannerInner">
      <slot></slot>
      <slot></slot>
    </div>
  </div>
</template>

<script>
const prefixCls = 'r--banner'

export default {
  name: 'Banner',
  provide () {
    return {
      banner: this
    }
  },
  props: {
    // 运动方向
    direction: {
      type: String,
      default: 'scrollLeft'
    },
    // 运动系数
    rate: {
      type: Number,
      default: 0.08
    },
    // setInterval 频率
    frame: {
      type: Number,
      default: 20
    },
    // 运动间隔
    gap: {
      type: Number,
      default: 2000
    },
    // 指针
    pointer: {
      type: Number,
      default: 0
    }
  },
  data () {
    return {
      list: [],
      mark: this.pointer,
      bannerWidth: 0,
      bannerHeight: 0
    }
  },
  computed: {
    wrapCls () {
      return [
        prefixCls
      ]
    },
    innerCls () {
      return `${prefixCls}-inner`
    },
    innerWidth () {
      let width = 0
      for (let i = 0; i < this.list.length; i++) {
        width += this.list[i].width
      }
      return width
    },
    innerHeight () {
      let height = 0
      for (let i = 0; i < this.list.length; i++) {
        height += this.list[i].height
      }
      return height
    },
    innerStyle () {
      return {
        width: `${this.innerWidth}px`
      }
    },
    distance () {
      return this.direction == 'scrollLeft' ? this.list[0].width : this.list[0].height
    }
  },
  mounted () {
    this.timer = setTimeout(this.goto, this.gap);
    this.bannerWidth = this.$refs.banner.offsetWidth
    this.bannerHeight = this.$refs.banner.offsetHeight
  },
  methods: {
    touchstartBannerInner (e) {
      clearTimeout(this.timer)
      clearInterval(this.gap_timer)
      this.lastScroll = this.$refs.banner[this.direction]
      this.startCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
    },
    touchmoveInner (e) {
      let currCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
      if (currCoor > this.startCoor && this.lastScroll == 0) {
        this.$refs.banner[this.direction] = (this.direction == 'scrollLeft' ? this.innerWidth : this.innerHeight) / 2
        this.lastScroll = (this.direction == 'scrollLeft' ? this.innerWidth : this.innerHeight) / 2
      }
      this.$refs.banner[this.direction] = this.lastScroll + this.startCoor - currCoor
    },
    touchendBannerInner (e) {
      let endCoor = e.changedTouches[0][this.direction == 'scrollLeft' ? 'clientX' : 'clientY']
      let movePercent = Math.abs(this.startCoor - endCoor) / (this.direction == 'scrollLeft' ? this.bannerWidth : this.bannerHeight) * 100
      if (movePercent > 20) {
        if (endCoor > this.startCoor) {
          this.mark -= 1
          this.gap_timer = setInterval(this.minus, this.frame);
        } else {
          this.goto()
        }
      } else {
        this.$refs.banner[this.direction] = this.lastScroll
      }
    },
    goto () {
      this.mark += 1
      this.gap_timer = setInterval(this.plus, this.frame);
    },
    // +动画
    plus () {
      clearTimeout(this.timer)
      let d = this.$refs.banner[this.direction]
      let l = this.list.length / 2
      if (d < this.mark * this.distance) {
        this.$refs.banner[this.direction] = Math.ceil(d + (this.mark * this.distance - d) * this.rate)
      } else {
        clearInterval(this.gap_timer)
        this.mark = this.mark < l ? this.mark : 0
        this.$refs.banner[this.direction] = this.mark * this.distance
        this.timer = setTimeout(this.goto, this.gap);
      }
    },
    // -动画
    minus () {
      clearTimeout(this.timer)
      let d = this.$refs.banner[this.direction]
      let l = this.list.length / 2
      if (d > this.mark * this.distance) {
        this.$refs.banner[this.direction] = Math.floor(d - (d - this.mark * this.distance) * this.rate)
      } else {
        clearInterval(this.gap_timer);
        this.mark = this.mark < 1 ? l : this.mark
        this.$refs.banner[this.direction] = this.mark * this.distance;
        this.timer = setTimeout(this.goto, this.gap);
      }
    }
  }
}
</script>

<style lang="less">
@bannerCls: r--banner;
.@{bannerCls} {
  position: relative;
  width: 100%;
  overflow: hidden;
  &-inner {
    position: relative;
    width: 10000px;
  }
  &-inner::after {
    content: "";
    display: block;
    clear: both;
  }
  &-inner-transition &-inner {
    transition: transform 0.5s ease-out;
  }
}
</style>
